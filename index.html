<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Cubic Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Cubic Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cubic Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Cubic Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cubic Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人博客，专注前端</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/28/idx22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/28/idx22/" itemprop="url">AJAX的原理及实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-28T11:56:01+08:00">
                2018-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>我可以发送请求，但是我很菜</strong><br>我们都知道，HTML很多标签都可以发起HTTP请求，但是它们都不太完美，有着各种各样的令人难以忍受的缺陷。比如：</p>
<ol>
<li>form表单可以发送GET或者POST请求，但是会刷新页面或者新开页面。</li>
<li>a标签也能发送GET请求，但是它也会刷新页面或者跳转到另一个页面。</li>
<li>img标签可以GET请求，但是返回的数据类型是图片形式，只能以图片的形式展示。</li>
<li>link标签也可以发送GET请求，但是只能以CSS或者favicon的形式展示。</li>
<li>script标签也可以发送GET请求，就是所谓的JSONP，但是只能以脚本的形式运行。</li>
</ol>
<p>以上这么多标签都可以发送请求，但是缺点很多，例如只能发送GET请求，或者会刷新跳转页面，或者展示形式不太灵活，这些都是我们不想看到的，难道就没有比较好的方式发起请求，有什么方法可以实现</p>
<ul>
<li>get、post、put、delete等什么请求都行</li>
<li>返回的数据想以什么形式展示都行</li>
</ul>
<p>这两个诉求在很长一段时间内都不能得到很好的满足，直到微软有了一个突破。  </p>
<p><strong>AJAX的诞生</strong><br>IE5率先在js中引入了ActiveX对象，使得JS可以直接发起HTTP请求，不需要借助于HTML标签。随后Mozilla、Safari、Opera也跟进了，引入了XMLHttpRequest，这个API被纳入了W3C规范，而微软的ActiveX并没有纳入规范。<br><strong>什么是AJAX</strong><br>Jesse James Garrett将如下技术取名为AJAX(Asynchronous JavaScript And XML),中文读作：异步的JavaScript和XML。它的特点是：</p>
<ol>
<li>使用XMLHttpRequest对象发起请求</li>
<li>服务器返回XML格式的的<strong>字符串</strong></li>
<li>JS解析XML，并更新局部页面</li>
</ol>
<p>由于在几年前后端与浏览器传送数据的格式一般是XML，所以取名为AJAX，但是现在不一样了，现在传送的数据格式一般是JSON。<br><strong>什么是JSON</strong><br>JSON是一种轻量级的数据交换<strong>语言</strong>，由道格拉斯·克罗克福特(Douglas Crockford)在JavaScript语法的基础上开发的，所以和JS比较像，它抄袭了js中的很多数据类型，包括string、number、null、true、false、object、array，它没有undefined、function以及Symbol，并且string和object的格式要求和js也略有不同。string类型都是包裹在双引号之中，object属性和值中的string也是如此，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//js中的string</span><br><span class="line">&quot;hello&quot;或者&apos;hello&apos;都可以</span><br><span class="line">//json中的string必须为</span><br><span class="line">&quot;hello&quot;</span><br><span class="line"></span><br><span class="line">//js中的普通object</span><br><span class="line">&#123;</span><br><span class="line">    name:&apos;jack&apos;,</span><br><span class="line">    job:&apos;engineer&apos;</span><br><span class="line">&#125;</span><br><span class="line">//json中的object</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;jack&quot;,</span><br><span class="line">    &quot;job&quot;:&quot;engineer&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//浏览器提供了API用于专门创建JSON格式的字符串</span><br><span class="line">以及解析JSON格式的字符串</span><br><span class="line">let obj=&#123;</span><br><span class="line">    name:&apos;jack&apos;,</span><br><span class="line">    job:&apos;engineer&apos;</span><br><span class="line">&#125;</span><br><span class="line">let jsonStr=JSON.stringify(obj);</span><br><span class="line">console.log(jsonStr) //结果为&apos;&#123;&quot;name&quot;:&quot;jack&quot;,&quot;job&quot;:&quot;engineer&quot;&#125;&apos;</span><br><span class="line"></span><br><span class="line">let str=`&#123;</span><br><span class="line">    &quot;name&quot;:&quot;jack&quot;,</span><br><span class="line">    &quot;job&quot;:&quot;engineer&quot;</span><br><span class="line">&#125;`</span><br><span class="line">let jsonObj=JSON.parse(str);//将字符串解析成了一个js普通对象</span><br></pre></td></tr></table></figure></p>
<p><strong>如何使用XMLHttpRequest发请求</strong><br>让我们看一下如何用原生JS代码利用XMLHttpRequest对象发起一个GET请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建一个XMLHttpRequest对象</span><br><span class="line">let xhr=new XMLHttpRequest();</span><br><span class="line">//配置一下请求的方法以及路径，是否支持异步</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;./xxx&apos;,true); //第三个参数默认为true,支持异步</span><br><span class="line">xhr.send();//发送请求</span><br><span class="line">xhr.onreadystatechange=()=&gt;&#123;</span><br><span class="line">    /*用于监听请求的状态*/</span><br><span class="line">    if(xhr.readyState===4)&#123;</span><br><span class="line">        if(xhr.status&gt;=200 &amp;&amp; xhr.status&lt;300)&#123;</span><br><span class="line">            let result=xhr.responseText;//后端返回的字符串数据</span><br><span class="line">            console.log(&apos;请求成功&apos;);</span><br><span class="line">        &#125;else if(xhr.status&gt;=400)&#123;</span><br><span class="line">            console.log(&apos;请求失败&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AJAX支持各种类型的请求，并且可以实现无刷新无跳转局部更新展示返回的数据。由于AJAX是如此的强大，如果不对它有所限制，那么我们上网是非常危险的，很容易暴露我们的隐私，于是浏览器同源策略诞生了。<br><strong>什么是同源策略</strong><br>只有<strong>协议+域名+端口</strong><em>一模一样</em>才允许发送AJAX请求，注意是一模一样，有一点不同都不行。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://baidu.com 可以向 http://www.baidu.com 发 AJAX 请求吗 no</span><br><span class="line">http://baidu.com:80 可以向 http://baidu.com:81 发 AJAX 请求吗 no</span><br></pre></td></tr></table></figure></p>
<p>但是有时候我们必须通过AJAX进行跨域请求，那么可以借助CORS实现，它需要后端的配合。CORS（cross-origin resource sharing）是跨域资源共享的意思，它实际上是在请求的域名后端设置允许跨域访问白名单的意思，具体的后端代码可以参考如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//node js后端代码参考如下，其他后端语言类似</span><br><span class="line">else if(path===&apos;/xxx&apos;)&#123;</span><br><span class="line">    response.statusCode=200;</span><br><span class="line">    response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://frank.com:8001&apos;);</span><br><span class="line">    //如果允许所有域名访问，可以如下设置</span><br><span class="line">    /*response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;*&apos;);*/</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;,&apos;application/json&apos;);</span><br><span class="line">    response.write(`</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;:&quot;jack&quot;,</span><br><span class="line">            &quot;age&quot;:18</span><br><span class="line">        &#125;</span><br><span class="line">    `);</span><br><span class="line">    response.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/idx21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/idx21/" itemprop="url">JSONP原理及实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T22:57:17+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前端与后端交互的辛酸史以及JSONP的运用"><a href="#前端与后端交互的辛酸史以及JSONP的运用" class="headerlink" title="前端与后端交互的辛酸史以及JSONP的运用"></a>前端与后端交互的辛酸史以及JSONP的运用</h3><p>前端程序员在早些的时候一般通过表单的方式将请求或更改的数据发送给后端，但是表单提交后，不管成功与失败，都要跳转到另一个页面，在另一个页面上呈现提交的结果，一般是“sucess”或者“fail”，用户为了看到这么两个单词必须等待一个新的页面打开，并且按历史回退到原来的页面，并且通常看到的还是缓存的旧页面，还要进行刷新才能看到操作之后页面的变化，所以用户体验超级超级差！于是悲催的前端程序员不得不为了提升用户体验绞尽脑汁想办法！<br><strong>改进一：怎样让表单提交之后不跳转页面</strong><br>机智的程序员在页面中嵌入一个iframe，将表单的target指向这个iframe的名字，于是表达提交之后就乖乖的在iframe中跳转了，并且用户能看到“sucess”或者“fail”，不错，于是为了提升客户那么一丢丢的体验，在很长一段时间内前端页面就是通过嵌入iframe的方式阻止表单提交后跳转的。但是用户还是得在表单提交之后重新刷新页面才能看到操作后的结果，程序员还得继续努力啊！<br><strong>改进二：听说img标签可以实现无刷新请求后端数据</strong><br>纳尼！这都可以！令人窒息的操作！是的，通过js代码动态创建一个img标签，然后将img的src指向后端服务器的某个路径，那么img就可以向后端服务器发起GET请求了，请注意，只能是GET请求，并且img标签无需插入到页面中也能发请求。哇塞！不错，但是怎么判断我请求成功还是失败了呢？听说一般加载资源都可以通过onload和onerror事件处理加载成功与失败的情况，这里好像同样适用。<br>这两个事件是如何判断资源请求成功与失败呢，是根据服务器响应传回的状态码进行判断，2XX表示成功，3XX表示重定向，4XX客户端错误，5XX服务器错误，一般返回2XX说明我们请求成功了，4XX就是失败了。但是img标签默认请求的是图片资源，如果我们想拿回文本数据，那么一般会请求失败，所以后端需要将数据类型进行伪装，设置“Content-Type”为“image/jpg”或”image/png”等图片MIME类型就好啦，有一种偷梁换柱，暗度陈仓的赶脚。拿回数据后你想怎么干就怎么干啦。但是哦，img标签必须需要后台配合伪装数据，那浏览器端拿到数据不就傻眼啦？这是图片呢还是图片呢还是图片呢，于是，于是，我们的JSONP就终于登场啦！<br><strong>改进三：闪亮登场的JSONP</strong><br>img有src，而script也有src，那么按道理script也可以请求后端数据，事实的确如此。我们通过js代码动态创建script标签，然后将它的src指向后端服务器上的某个路径，就能向后端服务器发起请求了吗？还不行，记住必须将script插入到页面中，否则不能发起请求。script插入页面中后，就会向后端发起请求，当请求成功并拿回数据后，就会插入script标签中，并且浏览器会将这段数据当做js代码执行，如果给script绑定了onload事件，之后就会执行这个事件中的逻辑。既然拿回数据后会当做js代码执行，那么onload事件就不是必须的了，只要将onload中的逻辑放到从后端拿回的数据中就好啦。但是这样做的话，后端程序员就哭啦，我不知道你前端写了啥，但我必须了解你的东西还要写点东西给你，请让我哭一会。好，这就叫做前端与后端的耦合，不了深入了解对方休想干事，于是前端了解了后端的苦楚之后，决定在src中多传你一个参数，参数值是一个前端定义好的函数名，后端只要将返回的数据当做第一个参数传到这个函数中，并且以字符串的形式返回给我，不需要后端做其他的，这就是解耦合啦。过程是这样的…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//前端</span><br><span class="line">var oScript=document.createElement(&apos;script&apos;);</span><br><span class="line">oScript.src=&quot;//jack.com/pay?callback=fn&quot;;</span><br><span class="line">function fn()&#123;</span><br><span class="line">    ....</span><br><span class="line">    逻辑代码</span><br><span class="line">&#125;</span><br><span class="line">//后端</span><br><span class="line">response.write(`fn.call(undefined,&#123;</span><br><span class="line">        &apos;name&apos;:&apos;jack&apos;,</span><br><span class="line">        &apos;age&apos;:&apos;18&apos;</span><br><span class="line">    &#125;)`);</span><br><span class="line">//后端返回的数据一般是JSON类型的，JSON前后有内容，</span><br><span class="line">所谓的JSON+padding，因此起了一个“JSONP”的莫名其妙</span><br><span class="line">的名字。通常函数名fn是通过后端解析查询参数得到的，</span><br><span class="line">所以后端程序员连传入的函数名都可以一无所知就完成</span><br><span class="line">他的工作，因此他们解放了，前端还得继续苦逼。</span><br></pre></td></tr></table></figure></p>
<p><strong>JSONP是基于动态创建script标签的，并且只能支持GET请求不支持POST请求</strong>。请求成功并且执行完后通常需要将页面中动态插入的script标签删除。前端传入的函数名一般是随机的，每次传入都会有所不同，可以写成如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fName=&apos;frank&apos;+parseInt(Math.random()*1000000);</span><br><span class="line">window[fName]=function()&#123;</span><br><span class="line">    处理逻辑...</span><br><span class="line">    delete window[fName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详细的代码可以访问：<a href="https://github.com/qianyuanjia/jsonp" target="_blank" rel="noopener">代码链接</a><br><strong>jQuery帮我们封装了JSONP</strong><br>jQuery一开始将JSONP封装在了ajax中，有点迷，后来又独立出来了，但是ajax实现方式还能用，不需要自己动态创建script，也不需要创建随机函数，jQuery已经疯转好了，代码演示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&apos;http://jack.com/pay&apos;,</span><br><span class="line">    dataType:&apos;jsonp&apos;,</span><br><span class="line">    success:function()&#123;</span><br><span class="line">        处理逻辑...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/idx20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/idx20/" itemprop="url">jQuery及其API的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T20:16:16+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先我们来写一个给节点对象添加样式类的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addClass(node,classArr)&#123;</span><br><span class="line">   for(let i=0;i&lt;classArr.length;i++)&#123;</span><br><span class="line">    node.classList.add(classArr)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上封装函数的函数虽然简单，但是存在一个问题，当我们封装很多这样的工具函数的时候，相当于在全局作用域下声明了很多变量，但是别人不知道我们声明了哪些变量，很容易引发变量名冲突覆盖的问题，于是我们引入了命名空间的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//命名空间封装函数</span><br><span class="line">var dom=&#123;&#125;</span><br><span class="line">dom.addClass=function(node,classArr)&#123;</span><br><span class="line">   for(let i=0;i&lt;classArr.length;i++)&#123;</span><br><span class="line">    node.classList.add(classArr)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line">dom.getSiblings=function()&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>采用命名空间的方式相当于在全局作用域下只暴露了一个全局变量，大大减小了变量冲突的可能性，但是使用函数的时候需要写一长串的函数名，比如dom.addClass(node,[‘a’,’b’,’c’]),我们习惯使用node.addClass([‘a’,’b’,’c’]),因此可以换一种方式封装函数，我们将封装的函数放在Node的原型下，由于所有的DOM对象都继承这个Node原型，所以所有的DOM都可以用我们习惯的方式使用这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//封装函数放在Node原型中</span><br><span class="line">Node.prototype.addClass=function(node,classArr)&#123;</span><br><span class="line">   for(let i=0;i&lt;classArr.length;i++)&#123;</span><br><span class="line">    node.classList.add(classArr)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是JS有许多函数库，如果每个函数库都在Node原型中封装函数，迟早会打架，于是每个函数库就在window全局对象下另起一个门户，比如jQuery就在window对象中声明了一个jQuery构造函数，作为使用jQuery众多API的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector)&#123;</span><br><span class="line">    let nodes=&#123;&#125;</span><br><span class="line">    //判断传入的是选择器还是node对象</span><br><span class="line">    if(typeof nodeOrSelector === &apos;string&apos;)&#123;</span><br><span class="line">        nodes=document.querySelectorAll(nodeOrSelector)</span><br><span class="line">    &#125;else if(nodeOrSelector instanceof Node)&#123;</span><br><span class="line">        //即使是node对象，也要将其封装为一个伪数组，以免返回值不同引发混淆</span><br><span class="line">        nodes=&#123;</span><br><span class="line">            0:nodeOrSelector,</span><br><span class="line">            length:1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.addClass=function(className)&#123;</span><br><span class="line">        for(let i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">            nodes[i].classList.add(className)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.setText=function()&#123;</span><br><span class="line">          for(let i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">            nodes[i].textContent=&apos;hi&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodes</span><br><span class="line">&#125;</span><br><span class="line">window.$ = jQuery //给jQuery起一个别名</span><br><span class="line"></span><br><span class="line">var $div = $(&apos;div&apos;)</span><br><span class="line">$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi</span><br></pre></td></tr></table></figure></p>
<p>jQuery()可以传入一个node对象或者各种选择器，返回一个包含node对象的伪数组，它是一个对象，它的属性中含有jQuery的各种API。与真正的jQuery不同的是，真正的jQuery将各种工具函数声明在jQuery原型中，不用为每个jQuery对象都保存一份相同的API。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/idx19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/idx19/" itemprop="url">JS函数知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-23T19:25:17+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-函数的5种声明方式"><a href="#1-函数的5种声明方式" class="headerlink" title="1. 函数的5种声明方式"></a>1. 函数的5种声明方式</h3><ul>
<li><p>具名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(x,y)&#123;</span><br><span class="line">    return x+y</span><br><span class="line">&#125;</span><br><span class="line">f.name //结果为&apos;f&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f=function(x,y)&#123;</span><br><span class="line">    return x+y</span><br><span class="line">&#125;</span><br><span class="line">f.name //结果为&apos;f&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具名函数赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f=function f2(x,y)&#123;</span><br><span class="line">    console.log(f2)</span><br><span class="line">    return x+y</span><br><span class="line">&#125;</span><br><span class="line">f.name //结果为&apos;f2&apos;</span><br><span class="line">console.log(f2) //undefined</span><br><span class="line">f.call(undefined,1,2) //打印出f2函数，并且返回值为3</span><br><span class="line">//f2变量在函数内部有效，函数外部使用会报错</span><br></pre></td></tr></table></figure>
</li>
<li><p>window.Function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&apos;x&apos;,&apos;y&apos;,&apos;return x+y&apos;)</span><br><span class="line">f.name //结果为&apos;anonymous&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f = (x,y) =&gt; &#123;</span><br><span class="line">    return x+y</span><br><span class="line">&#125;</span><br><span class="line">//箭头函数括号内为参数，方法体写在大括号中，没有函数名，</span><br><span class="line">当函数体内只有一条语句，并且是&apos;return 语句&apos;时，可以简写为如下形式：</span><br><span class="line">var f= (x,y) =&gt; x+y //大括号和return必须全都省略</span><br><span class="line">//当参数只有一个时，可以进一步省略小括号：</span><br><span class="line">var f = x =&gt; x*2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-用call-来调用函数"><a href="#2-用call-来调用函数" class="headerlink" title="2. 用call()来调用函数"></a>2. 用call()来调用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">f.call([arg1[,arg2,arg3...]])</span><br><span class="line">其中arg1是函数中this引用的对象，在普通模式下，如果传入的是</span><br><span class="line">除了null和undefined之外的简单类型，this就是简单类型的包装类对象，例如</span><br><span class="line">function fx()&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">fx.call(1) //this为new Number(1)</span><br><span class="line">fx.call(&apos;ss&apos;) //this为new String(&apos;ss&apos;)</span><br><span class="line">fx.call(true) //this为new Boolean(true)</span><br><span class="line">在普通模式下传入null和undefined时，浏览器会自动将this指向window对象</span><br><span class="line">fx.call(null) //this为window对象</span><br><span class="line">fx.call(undefined) //this为window对象</span><br><span class="line"></span><br><span class="line">在严格模式下，使用以下形式声明函数</span><br><span class="line">function fx()&#123;</span><br><span class="line">    &apos;use strict&apos;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">fx.call(1) //this为1</span><br><span class="line">fx.call(&apos;ss&apos;) //this为&apos;ss&apos;</span><br><span class="line">fx.call(undefined) //this为undefined</span><br><span class="line">这是this相当于一个普通形参，传入什么就是什么</span><br><span class="line"></span><br><span class="line">不管在严格模式还是普通模式下，如果第一个参数为对象类型的参数，</span><br><span class="line">那么this就指向这个对象，余下的参数放到arguments伪数组中。</span><br></pre></td></tr></table></figure>
<h3 id="3-什么是call-back"><a href="#3-什么是call-back" class="headerlink" title="3. 什么是call back?"></a>3. 什么是call back?</h3><p>call stack是一种跟踪记录函数调用的栈类型的数据结构。当执行一个函数时，就在call stack中压一次栈，当遇到return语句时，就弹出一个栈计数。每台计算机压栈的数量是有限的，当执行函数的递归层级很深时，很容易引发stack overflow错误。</p>
<h3 id="4-JS作用域"><a href="#4-JS作用域" class="headerlink" title="4. JS作用域"></a>4. JS作用域</h3><p>JS作用域是一个树形结构，最外层是全局作用域，当声明一个函数时，就开辟了一个子作用域，如果函数内部再声明函数，还会开辟函数的子作用域，最终形成作用域的树形结构。在作用域中查找变量是由内而外并且遵循‘就近原则’，形成一条作用域链。如果在作用域链上没有找到该变量，就相当于声明了一个全局变量并赋值。作用域只能帮我们确定是哪个变量，但不能确定变量的值。例如，以下是常见的面试题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">function f1()&#123;</span><br><span class="line">    alert(a) // 是多少</span><br><span class="line">    var a = 2</span><br><span class="line">&#125;</span><br><span class="line">f1.call()</span><br><span class="line">这题需要注意变量是预解析的，预解析时变量会提升到作用域顶部并赋值undefined。</span><br><span class="line"></span><br><span class="line">var a = 1</span><br><span class="line">function f1()&#123;</span><br><span class="line">    var a = 2</span><br><span class="line">    f2.call()</span><br><span class="line">&#125;</span><br><span class="line">function f2()&#123;</span><br><span class="line">    console.log(a) // 是多少</span><br><span class="line">&#125;</span><br><span class="line">f1.call()</span><br><span class="line">这题注意f2函数是在全局作用域下声明的，其中的变量a只会在f2函数内</span><br><span class="line">部以及全局作用域查找。</span><br></pre></td></tr></table></figure></p>
<h3 id="5-闭包的概念"><a href="#5-闭包的概念" class="headerlink" title="5. 闭包的概念"></a>5. 闭包的概念</h3><p>当一个函数使用了其作用域之外的变量时，这个函数以及变量叫做闭包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    let a=1</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">function f2()&#123;</span><br><span class="line">    let a=1 </span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line">var b=f2()</span><br><span class="line">b()</span><br><span class="line">console.log(a) //报错，a is not defined</span><br></pre></td></tr></table></figure></p>
<p>以上代码声明了两个函数f1以及f2，f1在被调用执行完之后，其作用域内的变量a就会在内存中销毁，下一次再调用f1时又会被重新创建。f2中的返回值是一个匿名函数，在匿名函数中使用到了处于f2作用域中的变量a，当f2被调用后，变量b就成了一个函数，这时奇迹放生了，f2调用执行完成之后，f2中的变量a并未被销毁，依然贮存在内存中，每次调用b时，依然可以打印出变量a的值，这就叫做闭包。在全局作用域下不能访问到变量a，但是调用b可以访问变量a，这就体现了闭包的一个好处，那就是可以减轻全局变量的污染。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/22/idx18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/idx18/" itemprop="url">原生JS操作DOM常用API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-22T23:14:00+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-JS中的节点类型"><a href="#1-JS中的节点类型" class="headerlink" title="1. JS中的节点类型"></a>1. JS中的节点类型</h3><p>JS中的节点类型有7种（Document、DocumentType、Element、Attribute、Text、Comment、DocumentFragment），其中(Document、Element、Text)是必须重点掌握的，区分节点类型的常用方法是使用节点的nodeType属性，它的值是一个整数，对应一种Node类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node.DOCUMENT_NODE:9</span><br><span class="line">Node.ELEMENT_NODE:1</span><br><span class="line">Node.ATTRIBUTE_NODE:2</span><br><span class="line">Node.TEXT_NODE:3</span><br><span class="line">//可以使用如下形式作为条件判断语句进行后续操作</span><br><span class="line">if(节点对象.nodeType == Node.ElEMENT_NODE)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">//或者更简单的</span><br><span class="line">if(节点对象.nodeType == 1)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当节点对象是元素节点时，可以使用节点的tagName或者nodeName属性进行区分节点的具体标签类型，它们的值是标签名的大写形式，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oUL.tagName = &apos;UL&apos;</span><br><span class="line">oA.tagName=&apos;A&apos;</span><br><span class="line">oDIV.tagName=&apos;DIV&apos;</span><br><span class="line"></span><br><span class="line">oUL.nodeName = &apos;UL&apos;</span><br><span class="line">oA.nodeName=&apos;A&apos;</span><br><span class="line">oDIV.nodeName=&apos;DIV&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-创建节点"><a href="#2-创建节点" class="headerlink" title="2. 创建节点"></a>2. 创建节点</h3><p>我们可以使用document.createElement()这个API创建任意类型的元素节点。只要给这个API传递一个元素节点名称的参数，它就能创建出相应的节点对象；可以使用document.createTextNode()创建文本节点，需要传入一个字符串作为文本节点的内容。但是用这两个API创建的节点对象仅仅存在于内存中，如果需要成为真正的DOM对象，需要使用appendChild()或者insertBefore()等API将其插入文档中。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建一个div对象</span><br><span class="line">var oDiv=document.createElement(&apos;div&apos;);</span><br><span class="line">//创建一个text节点</span><br><span class="line">var oText=document.createTextNode(&apos;我是一个文本节点&apos;);</span><br><span class="line">//将div对象以及文本节点插入body的最后部分</span><br><span class="line">document.body.appendChild(oDiv);</span><br><span class="line">document.body.appendChild(oText);</span><br><span class="line">//当连续插入多个文本节点时，每个文本节点被认为是单独的节点，</span><br><span class="line">可以使用normalize()将连续的文本节点合并为一个。</span><br><span class="line">var oText1=document.createTextNode(&apos;我是第一个文本节点&apos;);</span><br><span class="line">var oText2=document.createTextNode(&apos;我是第二个文本节点&apos;);</span><br><span class="line">document.body.appendChild(oText1);</span><br><span class="line">document.body.appendChild(oText2);</span><br><span class="line">document.body.normalize(); //合并连续的文本节点</span><br></pre></td></tr></table></figure></p>
<h3 id="3-克隆节点"><a href="#3-克隆节点" class="headerlink" title="3. 克隆节点"></a>3. 克隆节点</h3><p>cloneNode是用来返回创建某个节点的一个副本，它接收一个bool类型的参数。如果传入的值为true，表示复制节点以及它的子节点。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var newDiv=oDiv.cloneNode(true) //克隆div及其子元素</span><br></pre></td></tr></table></figure></p>
<p>同createElement一样，克隆的节点只存在于内存中，如果想要插入文档中，需要借助appendChild或者insertBefore等API。</p>
<h3 id="4-创建文档碎片"><a href="#4-创建文档碎片" class="headerlink" title="4. 创建文档碎片"></a>4. 创建文档碎片</h3><p>由于创建节点以及插入文档流的过程是一个及其消耗浏览器性能的过程，因此尽量避免在DOM以及JS之间频繁交互。通过创建一个文档碎片作为新创建对象的容器，最后把文档碎片插入到DOM中，是一种优化网站性能的方式。使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var oFrag=document.createFragment()</span><br><span class="line">var oDiv=document.createElement(&apos;div&apos;)</span><br><span class="line">oFrag.appendChild(oDiv)</span><br><span class="line">...//之后还可以插入更多的元素</span><br><span class="line">document.body.appendChild(oFrag) //最后将文档碎片插入文档中</span><br></pre></td></tr></table></figure></p>
<h3 id="5-插入、删除、替换DOM节点"><a href="#5-插入、删除、替换DOM节点" class="headerlink" title="5. 插入、删除、替换DOM节点"></a>5. 插入、删除、替换DOM节点</h3><ul>
<li><p>appendChild<br>这个API的使用形式如下，用于在父节点末尾插入一个节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.appendChild(childNode)</span><br></pre></td></tr></table></figure>
</li>
<li><p>insertBefore<br>这个API用于在父节点中的其中一个子节点之前插入一个节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.insertBefore(newNode,childNode)</span><br></pre></td></tr></table></figure>
</li>
<li><p>removeChild<br>这个API用于删除父节点中的一个子节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.removeChild(childNode)</span><br></pre></td></tr></table></figure>
</li>
<li><p>replaceChild<br>这个API用于替换父节点中的一个子节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.replaceChild(newNode,childNode)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-Node的API"><a href="#6-Node的API" class="headerlink" title="6. Node的API"></a>6. Node的API</h3><p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等。</p>
<ul>
<li>父关系型api<br><strong>parentNode</strong>：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。<br><strong>parentElement</strong>：返回元素的父元素节点，与parentNode的区别在于，<em>其父节点必须是一个Element，如果不是，则返回null</em>。</li>
<li>兄弟关系型api<br><strong>previousSibling</strong>：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br><strong>previousElementSibling</strong>：返回前一个元素节点，前一个节点必须是Element，<em>注意IE9以下浏览器不支持</em>。<br><strong>nextSibling</strong>：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br><strong>nextElementSibling</strong>：返回后一个元素节点，后一个节点必须是Element，<em>注意IE9以下浏览器不支持</em>。</li>
<li>子关系型api<br><strong>childNodes</strong>：返回一个<em>即时的NodeList</em>，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br><strong>children</strong>：一个<em>即时的HTMLCollection</em>，子节点都是Element，<em>IE9以下浏览器不支持</em>。<br><strong>firstNode</strong>：第一个子节点，可能是文本节点或注释节点。<br><strong>lastNode</strong>：最后一个子节点，可能是文本节点或注释节点。<br><strong>hasChildNodes</strong>方法：可以用来判断是否包含子节点。<br><strong>innerText</strong>:该属性值为节点中所有（包括子节点中）文本节点的内容，但是会忽略隐藏的元素以及style、script标签中的文本。</li>
<li>获取文本节点api<br><strong>textContent</strong>:该属性同样是返回节点中所有文本节点中的内容，但是不会忽略style以及script节点，隐藏元素中的文本内容同样会获取到。<br><strong>innerText与textContent的区别</strong>:innerText在获取文本节点之前首先会扫描节点的CSS属性，所以性能比较低，textContent没有这个过程，所以会比较快，并且它们获取的节点对象范围也有差异，前面已经提到，不再赘述。</li>
<li>两个容易混淆的方法<br>isEqualNode()和isSameNode()，两者差异类似于’==’和’===’之间的差异。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;   </span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;span&gt;我们长得一样&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;span&gt;我们长得一样&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">document.body.children[0].isEqualNode(document.body.children[1]) //true</span><br><span class="line">document.body.children[0].isSameNode(document.body.children[1]) //false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-节点查询型API"><a href="#7-节点查询型API" class="headerlink" title="7. 节点查询型API"></a>7. 节点查询型API</h3><ul>
<li><p>document.getElementById<br>这个接口很简单，根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。<br>使用这个接口有几点要注意：<br>（1）元素的Id是大小写敏感的，一定要写对元素的id<br>（2）HTML文档中可能存在多个id相同的元素，则返回第一个元素<br>（3）只从文档中进行搜索元素，如果创建了一个元素并指定id，但并没有添加到文档中，则这个元素是不会被查找到的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;box&apos;)</span><br><span class="line">//只有在Document节点下存在这个API，并且该API只能</span><br><span class="line">获取已经存在于文档中的静态DOM，后期动态添加的DOM获取不到。</span><br></pre></td></tr></table></figure>
</li>
<li><p>getElementsByTagName<br>这个接口根据元素标签名获取元素，返回一个即时的HTMLCollection类型，什么是即时的HTMLCollection类型呢？HTMLCollcetion元素是即时的表示该集合是随时变化的，也就是是文档中有几个div，它会随时进行变化，当我们新增一个div后，再访问HTMLCollection时，就会包含这个新增的div。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oDiv.getElementsByTagName(&apos;span&apos;);</span><br><span class="line">//这个接口任何元素节点都可以调用，并且后期动态添加的DOM也能获取到。</span><br></pre></td></tr></table></figure>
</li>
<li><p>document.getElementsByName<br>getElementsByName主要是通过指定的name属性来获取元素，它返回一个即时的NodeList对象。<br>使用这个接口主要要注意几点：<br>（1）返回对象是一个即时的NodeList，它是随时变化的<br>（2）在HTML元素中，并不是所有元素都有name属性，比如div是没有name属性的，但是如果强制设置div的name属性，它也是可以被查找到的<br>（3）在IE中，如果id设置成某个值，然后传入getElementsByName的参数值和id值一样，则这个元素是会被找到的，所以最好不好设置同样的值给id和name。</p>
</li>
<li>document.getElementsByClassName<br>这个API是根据元素的class返回一个即时的HTMLCollection。<br>这个接口有下面几点要注意：<br>（1）返回结果是一个即时的HTMLCollection，会随时根据文档结构变化<br>（2）IE9以下浏览器不支持<br>（3）如果要获取含有2个以上类的元素，可传入多个classname，每个用空格相隔。</li>
<li>document.querySelector和document.querySelectorAll<br>这两个api很相似，通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。<br>首先来介绍一下document.querySelector。<br>document.querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。<br>注意，由于返回的是第一个匹配的元素，这个api使用的深度优先搜索来获取元素。<br>document.querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符。<br>（1）querySelectorAll也是通过深度优先搜索，搜索的元素顺序和选择器的顺序无关<br>（2）返回的是一个非即时的NodeList，也就是说结果不会随着文档树的变化而变化<br>兼容性问题：querySelector和querySelectorAll在ie8以下的浏览器不支持。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&apos;ul li&apos;) //只返回一个li对象或者为null</span><br><span class="line">document.querySelector(&apos;ul li&apos;) //返回一个符合选择器的li伪数组</span><br><span class="line">//querySelectorAll可以使用组合选择器</span><br><span class="line">document.querySelectorAll(&apos;ul li,li a&apos;)</span><br><span class="line">//这两个API返回的都是静态DOM，后期动态添加的获取不到</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/21/idx17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/idx17/" itemprop="url">JS原型与原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-21T10:40:24+08:00">
                2018-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JS中的原型以及原型链概念只存在于对象类型数据。当一个对象被创建时，JS解析器做了两件事，创建一个哈希表用于描述对象的属性和方法，自动创建一个’__proto__‘属性用于绑定对象的某些共有属性，也就是所谓的原型。因此，原型就是同一类对象的共有属性，创建原型的目的就是节省内存开销，因为对同一类所有对象开辟内存用于存放相同的属性和方法是很奢侈的。原型是把同一类对象相同的属性和方法抽取出来独立成一个对象，当新创建一个对象时，这个对象的’__proto__‘属性就会自动引用原型对象。原型是一个对象，必须有’人’（比喻一下，实际上是变量或对象属性的意思）来引用它，否则会被gc掉。ES内置了Number、String、Boolean、Object、Function等构造函数，通过这些构造函数可以创建相应的数据对象。因为原型先于对象存在，所以在对象创建前就已经有’人’引用了它，那么这个’人’是谁呢？它就是构造函数的prototype属性，构造函数的实质也是对象，因此它也可以存在属性，所以我们通过构造函数创建一个对象之后，就用如下的对应关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var 对象 = new 函数();</span><br><span class="line">对象.__proto__ === 函数.prototype //结果为true</span><br><span class="line"></span><br><span class="line">/*既然函数也是对象，因此满足可以得到如下关系*/</span><br><span class="line">var 函数 = new Function();</span><br><span class="line">函数.__proto__ === Function.prototype</span><br></pre></td></tr></table></figure></p>
<p>JS中的Object构造函数比较特殊，它是所有对象的祖先，所有对象都拥有Object原型中的属性和方法，比如toString()方法以及hasOwnProperty属性等。以String对象举例说明一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = new String();</span><br><span class="line">a.__proto__ === String.prototype //结果为true</span><br><span class="line">a.__proto__.__proto__ === Object.prototype //结果为true</span><br><span class="line">/*由于Object的原型已经是最顶级的了，它没有再引用其他的原型对象，所以*/</span><br><span class="line">a.__proto__.__proto__.__proto__ === Object.prototype.__proto__ ==== null</span><br></pre></td></tr></table></figure></p>
<p>原型链实际上就是对象通过__proto__属性依次引用（指向）各个原型形成的一个链表结构，对象查找它的属性就是沿着原型链查找的，如果找到了就马上停止，不再沿着原型链找下去了，这就是所谓的’就近原则’。给张图示意一下原型和原型链的结构，红色的线代表一条原型链：<br><img src="/2018/05/21/idx17/pro.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/20/idx16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/idx16/" itemprop="url">JS数据类型转换以及内存中的数据存储方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T19:48:54+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-如何将其他数据类型转换为字符串？"><a href="#1-如何将其他数据类型转换为字符串？" class="headerlink" title="1. 如何将其他数据类型转换为字符串？"></a>1. 如何将其他数据类型转换为字符串？</h3><ul>
<li><p>toString()是除了null和undefined之外其他数据类型都有的一个API，能将数据内容转换为字符串，它不能转换null和undefined，会报错。数字使用toString转字符串需要用括号括起来,否则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1).toString() //结果为&apos;1&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>String()是一个包装类方法，能够将所有类型的数据转换为字符串，因此比toString()方法更强大。使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String(1) //结果为&apos;1&apos;</span><br><span class="line">String(null) //结果为&apos;null&apos;</span><br><span class="line">String(undefined) //结果为&apos;undefined&apos;</span><br><span class="line">/*转对象的时候很特殊*/</span><br><span class="line">String(&#123;&#125;) //结果为&apos;[object Object]&apos;</span><br><span class="line">String([1,2]) //结果为&apos;1,2&apos;</span><br><span class="line">String([]) //结果是&apos;&apos;</span><br><span class="line">String(&#123;a:1,b:2&#125;) //结果为&apos;[object Object]&apos;</span><br><span class="line">String(function()&#123;&#125;) //结果为&apos;function()&#123;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一种更为简单有效的方法是所有要转换的数据加上一个空字符串，结果就是该数据转换为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1+&apos;&apos; //结果是&apos;1&apos;</span><br><span class="line">null +&apos;&apos; //结果是&apos;null&apos;</span><br><span class="line">undefined+&apos;&apos; //结果是&apos;undefined&apos;</span><br><span class="line">/*转对象的时候千万要注意，它超级特殊*/</span><br><span class="line">&#123;&#125;+&apos;&apos; //结果是&apos;0&apos;</span><br><span class="line">[1,2]+&apos;&apos; //结果是&apos;1,2&apos;</span><br><span class="line">[]+&apos;&apos;//结果是&apos;&apos;</span><br><span class="line">&#123;a:1,b:2&#125; //报错</span><br><span class="line">&apos;&apos;+&#123;a:1,b:2&#125; //结果为&apos;[object Object]&apos;</span><br><span class="line">function()&#123;&#125;+&apos;&apos; //报错</span><br><span class="line">&apos;&apos;+function()&#123;&#125; //结果为&apos;function()&#123;&#125;&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>综合以上情况，其他数据类型转字符串时，除了对象类型之外需要特别注意，另外数据类型的套路都是差不多滴,并且采用空字符串相加的方式转字符串时最好将空字符串写前面。</p>
<h3 id="2-如何将其他数据类型转换为数字？"><a href="#2-如何将其他数据类型转换为数字？" class="headerlink" title="2. 如何将其他数据类型转换为数字？"></a>2. 如何将其他数据类型转换为数字？</h3></li>
<li><p>使用Number()包装类方法，转换的结果要么是数字，要么是NaN。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Number(&apos;123&apos;) //结果是123</span><br><span class="line">Number(&apos;12s&apos;) //结果是NaN</span><br><span class="line">Number(&apos;&apos;) //结果是0</span><br><span class="line">Number(true) //结果是1</span><br><span class="line">Number(false) //结果是0</span><br><span class="line">Number(null) //结果是0</span><br><span class="line">Number(undefined) // 结果是NaN</span><br><span class="line">Number([]) //结果是0</span><br><span class="line">Number([1]) //结果是1</span><br><span class="line">Number([1,3]) //结果是NaN</span><br><span class="line">Number(&#123;&#125;) //结果是NaN</span><br><span class="line">Number(&#123;a:1,b:2&#125;) //结果是NaN</span><br></pre></td></tr></table></figure>
</li>
<li><p>parseInt和parseFloat API<br>前者转换的结果是整数，后者转换的结果是整数或者浮点数，并且parseInt接收第二个参数，也就是以什么进制转换为十进制数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;12&apos;) //结果是12</span><br><span class="line">parseInt(&apos;12.5&apos;) //结果是12，不是四舍五入，而是直接舍去小数点后的数字</span><br><span class="line">parseInt(&apos;12s&apos;) //结果是12,这就是比Number强大的地方</span><br><span class="line">parseInt(&apos;11&apos;,8) //将八进制转十进制，结果是9</span><br><span class="line">parseFloat(&apos;1&apos;) //结果为1</span><br><span class="line">parseFloat(&apos;1.2&apos;) //结果为1.2</span><br><span class="line">parseFloat(&apos;12.1s&apos;) //结果是12.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过’+’操作符转换，’-‘也可以，但取的是相反数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+&apos;123&apos; //结果是123</span><br><span class="line">+&apos;-123&apos; //结果是-123</span><br><span class="line">+&apos;123s&apos; //结果是NaN</span><br><span class="line">-&apos;123&apos; //结果是-123</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-如何将其他数据类型转换为布尔类型"><a href="#3-如何将其他数据类型转换为布尔类型" class="headerlink" title="3. 如何将其他数据类型转换为布尔类型"></a>3. 如何将其他数据类型转换为布尔类型</h3><ul>
<li>通过Boolean()包装类方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean(1) //结果是true</span><br><span class="line">Boolean(0) //结果是false</span><br><span class="line">Boolean(NaN) //结果是false</span><br><span class="line">Boolean(&apos;sd&apos;) //结果是true</span><br><span class="line">Boolean(&apos;&apos;) //结果是false</span><br><span class="line">Boolean(null) //结果是false</span><br><span class="line">Boolean(undefined) //结果是false</span><br><span class="line">Boolean(&#123;&#125;) //结果是true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>根据以上结果总结出5个falsy(转成bool类型为false,但本身并不是bool类型)值：0，NaN，’’，null，undefined。</p>
<ul>
<li>通过’!!’转换成布尔类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!! 1 //结果是true</span><br><span class="line">!! 0 //结果是false</span><br><span class="line">!! &apos;sd&apos; //结果是true</span><br><span class="line">.</span><br><span class="line">.知道用法就可以啦，结果和上面那种方法是一样的</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-变量和数据时如何在内存中存储的？"><a href="#4-变量和数据时如何在内存中存储的？" class="headerlink" title="4. 变量和数据时如何在内存中存储的？"></a>4. 变量和数据时如何在内存中存储的？</h3><p>内存可以划分为两个区块，代码区和数据区，而数据区有可以分为栈内存和堆内存两部分。代码区存放的是代码，我们的变量名就存放在代码区，而变量值则存放在数据区。变量值可以分为简单类型和复杂类型，简单类型（数字、字符串、布尔值、null、undefined、Sybmbol）都存放在栈内存中，按照一定的顺序依次存放。复杂类型也就是对象类型分两部分存放，栈内存中存放的是其堆内存地址，堆内存中存放的就是对象的内容，堆内存中是乱序存放的。复杂类型变量名对应的值是栈内存中存放的地址，根据这个地址就可以在对内存中找到具体的值，所以复杂类型的变量赋值也叫做对象的引用，跟C语言中的指针相似，但js中并不存在指针的概念，所以用对象的引用这个概念来替代。变量赋值实质上就是改变存储在栈内存中的值，并不影响堆内存中的内容。</p>
<h3 id="5-浏览器的垃圾回收机制"><a href="#5-浏览器的垃圾回收机制" class="headerlink" title="5. 浏览器的垃圾回收机制"></a>5. 浏览器的垃圾回收机制</h3><p>当没有任何变量对堆内存中的对象进行引用的时候，这些对象就会成为垃圾，应该被回收并且释放内存。浏览器就会不定时地检测这些没有’主人’的对象并将其销毁，这就是浏览器的垃圾回收机制（GC）。现代主流浏览器在页面关闭的时候都会自觉的进行gc释放内存，但是IE6以下却并没有这个自觉，所以IE6以下浏览器存在内存泄漏的BUG，解决方法是在window.onunload事件中主动将所有使用的事件处理函数声明为null。</p>
<h3 id="6-深拷贝和浅拷贝"><a href="#6-深拷贝和浅拷贝" class="headerlink" title="6. 深拷贝和浅拷贝"></a>6. 深拷贝和浅拷贝</h3><p>深拷贝指的是从一个变量复制出另一个变量，其中一个变量的改变并不会影响另一个变量，这就是深拷贝。顾名思义浅拷贝就是复制的变量以及原始变量其中一个发生变化，那么两个变量值都会变。简单变量的赋值就是深拷贝。复杂变量需要用递归遍历的手段实现深拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//写一个对象深拷贝方法</span><br><span class="line">function deepCopy(obj)&#123;</span><br><span class="line">    var newObj=&#123;&#125;;</span><br><span class="line">    for(var key in obj)&#123;</span><br><span class="line">        if(typeof obj[key] != &apos;object&apos;)&#123;</span><br><span class="line">            newObj[key]=obj[key];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            newObj[key]=deepCopy(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/idx15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/idx15/" itemprop="url">JS里的数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T22:54:34+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>js里主要有7种数据类型，分别是数字类型，字符串类型，布尔类型，symbol类型，null，undefined以及对象。</strong></p>
<h3 id="1-数字类型"><a href="#1-数字类型" class="headerlink" title="1. 数字类型"></a>1. 数字类型</h3><p>数字类型也叫‘Number’类型，js里面的数字可以为整数，也可以为小数，可以用科学计数法表示数，但不管是整数还是小数，都以64位的浮点数进行存储。数字还可以用二进制表示，比如0b111，也可用八进制表示，比如0o61或（061）,也可以用十六进制表示，比如0xaa，其中大小写没有区分。js里面小数的算数运算是不精确的，比如‘0.1+0.2=0.30000000000000004’，这点很重要，切记。还有一个特殊的数字类型NaN，它表示的是不是数字的数字，比如’a’-1的结果就是NaN。typeof NaN的结果依然是number,所以它比较特殊，并且NaN == NaN为false。</p>
<h3 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2. 字符串类型"></a>2. 字符串类型</h3><p>字符串类型也叫‘String’类型，可以用双引号或者单引号括起来。但是如果字符串中有特殊字符，如果单引号之间还要插入单引号或者双引号之间插入双引号，必须用’\’进行转义。字符串连接用’+’,数字与字符串相加结果为字符串。字符串转换为数字类型用parseInt()或parseFloat()。当字符串很长时，可以用’\’换行，但’\’后面不能有任何字；也可以用’+’连接，这是最推荐的。并且可以用ES6的模板字符串表示，即用反引号括起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//长字符串换行</span><br><span class="line">var str=&apos;xxxxxxx&apos;+</span><br><span class="line">&apos;yyyyyyy&apos;+</span><br><span class="line">&apos;zzzzz&apos;;//这是最推荐的</span><br><span class="line"></span><br><span class="line">var str=&apos;xxxxxxx\</span><br><span class="line">yyyyyyy\</span><br><span class="line">zzzzz&apos;;//&apos;\&apos;后面不能有任何字符</span><br><span class="line"></span><br><span class="line">var str=`xxxxxxx</span><br><span class="line">yyyyyyy</span><br><span class="line">zzzzz`;//可以自由书写，但是换行和空格是包含在字符串中的。</span><br></pre></td></tr></table></figure></p>
<h3 id="3-布尔类型"><a href="#3-布尔类型" class="headerlink" title="3. 布尔类型"></a>3. 布尔类型</h3><p>布尔类型也叫‘Boolean’类型，只有两个值，分别为true和false。在条件语句如’if’中的条件表达式，最后得到的值必须为布尔类型，所以其他类型的数据在条件表达式中会隐式地转换为布尔类型。例如’’,0,undefined,null等会转换为false。</p>
<h3 id="4-symbol类型"><a href="#4-symbol类型" class="headerlink" title="4. symbol类型"></a>4. symbol类型</h3><p>symbol是ES6引入的一个新的数据类型。’Symbol()’可以创建一个独一无二的值，但它不是字符串。typeof Symbol()的结果是Symbol。可以在创建Symbol的时候给每个Symbol起一个名字，比如Symbol(‘XXX’),但是Symbol的值和名字并没有一一对应的关系，也就是说Symbol(‘a’) != Symbol(‘a’)为true。总之，Symbol会生成一个全局唯一的值。</p>
<h3 id="5-undefined"><a href="#5-undefined" class="headerlink" title="5. undefined"></a>5. undefined</h3><p>当变量声明之后未被赋值，变量的初始值默认是undefined。如果要给非对象的变量赋值，推荐使用undefined，只要用var xxx声明下就好了。</p>
<h3 id="6-null"><a href="#6-null" class="headerlink" title="6. null"></a>6. null</h3><p>typeof null的结果是object，这个很特殊，切记。null通常用于对象变量的初始化赋值。那么除了赋值使用上的不同之外，undefined和null之间还有哪些区别呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null == undefined //结果为true</span><br><span class="line">null === undefined //结果为false</span><br></pre></td></tr></table></figure></p>
<h3 id="7-对象"><a href="#7-对象" class="headerlink" title="7. 对象"></a>7. 对象</h3><p>js中除了以上6中数据类型，其他都是对象。函数也是对象，但是typeof fn结果为function。js中没有Array以及json类型，它们都是对象。对象的实质是哈希表，有一个个键值对组成的集合，没有顺序可言。获取对象所有键的API是Object.keys(),遍历对象的语句是for…in循环。</p>
<h3 id="8-能准确判断数据类型的一个方法"><a href="#8-能准确判断数据类型的一个方法" class="headerlink" title="8. 能准确判断数据类型的一个方法"></a>8. 能准确判断数据类型的一个方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(&apos;abc&apos;)     //&quot;[object String]&quot;</span><br><span class="line">Object.prototype.toString.call(123)       //&quot;[object Number]&quot;</span><br><span class="line">Object.prototype.toString.call(true)      //&quot;[object Boolean]&quot;</span><br><span class="line">Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;</span><br><span class="line">Object.prototype.toString.call(null)      //&quot;[object Null]&quot;</span><br><span class="line"></span><br><span class="line">Object.prototype.toString.call(&#123;&#125;)        //&quot;[object Object]&quot;</span><br><span class="line">Object.prototype.toString.call([])        //&quot;[object Array]&quot;</span><br><span class="line">Object.prototype.toString.call(function()&#123;&#125;) //&quot;[object Function]&quot;</span><br><span class="line"></span><br><span class="line">//根据以上内容自己封装一个判断数据类型的API</span><br><span class="line">var valide = (function()&#123;</span><br><span class="line">    // 是否是字符串</span><br><span class="line">    function isString(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object String]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否是数字</span><br><span class="line">    function isNumber(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Number]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否undefined</span><br><span class="line">    function isUndefined(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Undefined]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否是null</span><br><span class="line">    function isNull(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Null]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否是布尔值</span><br><span class="line">    function isBoolean(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Boolean]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否是对象</span><br><span class="line">    function isObject(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Object]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否数组</span><br><span class="line">    function isArray(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Array]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否是函数</span><br><span class="line">    function isFunction(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Function]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否是正则表达式</span><br><span class="line">    function isRegExp(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object RegExp]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否是日期对象</span><br><span class="line">    function isDate(value)&#123;</span><br><span class="line">        return Object.prototype.toString.call(value) == &quot;[object Date]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/idx14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/idx14/" itemprop="url">用Canvas实现图片裁剪和保存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T13:31:43+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="先来简单看下效果"><a href="#先来简单看下效果" class="headerlink" title="先来简单看下效果"></a>先来简单看下效果</h3><p><img src="/2018/05/18/idx14/clip.gif" alt=""></p>
<h3 id="1-html结构内容"><a href="#1-html结构内容" class="headerlink" title="1. html结构内容"></a>1. html结构内容</h3><p>html内容十分简单，我们需要一个input:file按钮用于上传本地图片，一个连接按钮用于图片保存，一个div用作选择遮罩，一个img用于预览裁剪结果，由于内容比较简单，所以这部分放一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    #mark&#123;</span><br><span class="line">        background-color: rgba(255,255,255,0.5);</span><br><span class="line">        position: absolute;</span><br><span class="line">        display: none;</span><br><span class="line">        cursor: move;</span><br><span class="line">    &#125;</span><br><span class="line">    #show&#123;</span><br><span class="line">        display: none;</span><br><span class="line">        margin-left: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;pic&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;&quot; id=&quot;save&quot;&gt;下载裁剪图&lt;/a&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;div id=&quot;mark&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;img src=&quot;&quot; alt=&quot;&quot; id=&quot;show&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-如何让选中的图片显示在页面上？"><a href="#2-如何让选中的图片显示在页面上？" class="headerlink" title="2. 如何让选中的图片显示在页面上？"></a>2. 如何让选中的图片显示在页面上？</h3><p>首先上传的图片存储于input:file对象的files属性中，并以数组的方式存储。接下来我们要将图片读取成文件对象，这部分需要用到FileReader API,通过FileReader对象的readAsDataURL方法可以读取input:file里的文件列表里面的图片，并将图片转换为base64格式。当FileReader对象将图片加载完之后，触发它的onload的事件，可以打印下事件对象函数的具体内容，发现其ev.target.result就是图片转成base64的一长串URI，通过创建一个Image对象并且将这串URI作为Image对象的src，这时，我们已经将上传的图片保存在内存中了，最后可以通过Canvas的上下文内容对象的drawImage方法，将Image对象画在画布中，图片就展示到页面上啦！</p>
<h3 id="3-如何下载和保存图片？"><a href="#3-如何下载和保存图片？" class="headerlink" title="3. 如何下载和保存图片？"></a>3. 如何下载和保存图片？</h3><p>通过下面这个方法就搞定啦，这个方法需要两个参数，一个是图片的base64格式内容，另一个是图片名称（自定义）。这个方法看不懂没关系，把它当成一个通用的API就好啦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function saveFile(data,filename)&#123;</span><br><span class="line">       var save_link=document.createElementNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;a&apos;);</span><br><span class="line">       save_link.href=data;</span><br><span class="line">       save_link.download=filename;</span><br><span class="line">       var event=document.createEvent(&apos;MouseEvents&apos;);</span><br><span class="line">       event.initMouseEvent(&apos;click&apos;,true,false,window,0,0,0,0,0,false,false,false,false,0,null);</span><br><span class="line">       save_link.dispatchEvent(event);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-我已将js代码上传到github中，有兴趣的可以访问"><a href="#4-我已将js代码上传到github中，有兴趣的可以访问" class="headerlink" title="4. 我已将js代码上传到github中，有兴趣的可以访问"></a>4. 我已将js代码上传到github中，有兴趣的可以访问</h3><p><a href="https://github.com/qianyuanjia/jsexcise/blob/master/js/haizei.js" target="_blank" rel="noopener">详细js代码</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/idx13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qian YJ">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cubic Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/idx13/" itemprop="url">常见的排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T19:54:03+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-冒泡排序算法"><a href="#1-冒泡排序算法" class="headerlink" title="1. 冒泡排序算法"></a>1. 冒泡排序算法</h3><p>请看原理图，相信你一看就懂，给它取个昵称‘两两摸头算法’。<br><img src="/2018/05/15/idx13/bub.gif" alt=""><br>下面是伪代码流程图<br><img src="/2018/05/15/idx13/bubflow.png" alt=""></p>
<h3 id="2-选择排序算法"><a href="#2-选择排序算法" class="headerlink" title="2. 选择排序算法"></a>2. 选择排序算法</h3><p>挑出一组中最大的放最后，或最小的放最前，余下的数字又组成一组继续选出最大或最小放在相应的位置，重复这个过程，直到余下最后一个数，那就已经OVER啦。<br>请看原理图，相信你一看就懂。<br><img src="/2018/05/15/idx13/sel.gif" alt=""><br>下面是伪代码流程图<br><img src="/2018/05/15/idx13/selflow.png" alt=""></p>
<h3 id="3-插入排序算法"><a href="#3-插入排序算法" class="headerlink" title="3. 插入排序算法"></a>3. 插入排序算法</h3><p>这个算法也叫起扑克牌算法，每次从队列中挑出一个数放入一个新的数组，放入之前需要和最后一个数比较，如果比它大，直接放最后，比它小，继续和前一个数比较，直到这个数的前面没有比它更大的数为止。请看原理图，相信你一看就懂。<br><img src="/2018/05/15/idx13/ins.gif" alt=""></p>
<h3 id="4-快速排序算"><a href="#4-快速排序算" class="headerlink" title="4. 快速排序算"></a>4. 快速排序算</h3><p>从队列中选出一个数作为分界点，余下的数依次和它比较，比它大的放右边，比它小的放左边，这样就形成了左右两个独立的队列，并且作为分界点的数的位置已被固定了。再从左右两边分别选出一个数作为分界点，左边的队列和右边的队列作为独立的队列重复这个比较以及放置过程，最终独立队列的长度越来越小，位置确定的数字越来越多，直至所有数字的位置都被确定。由于每次确定独立队列之后，比较的次数都会减少很多，所以这个算法叫做快速排序算法。当按顺序选择分界点，比如从左往右依次选择，很可能出现所有数字分布在分界点的一边打额情况，为了尽可能<br>减少这个几率，可以选择随机快速排序，即选择分界点是随机的。<br>请看原理图，相信你一看就懂。<br><img src="/2018/05/15/idx13/qui.gif" alt=""></p>
<h3 id="5-基数排序算法"><a href="#5-基数排序算法" class="headerlink" title="5. 基数排序算法"></a>5. 基数排序算法</h3><p>将所有可能出现的数字依次排序，每个可能出现数字所在的位置作为一个数字容器，如果队列中出现了这个数字，就把这个数字放在相应的容器中。最后按照可能出现数字的排列顺序，依次从每个容器中取出数字，那么排序自然就已经OVER啦。这个算法由于不需要比较，所以会很快，但是设立数字容器可能会消耗很多的内存，数字较少的时候使用还是很OK的。请看原理图，相信你一看就懂。<br><img src="/2018/05/15/idx13/red.gif" alt=""></p>
<h3 id="6-计数排序算法"><a href="#6-计数排序算法" class="headerlink" title="6. 计数排序算法"></a>6. 计数排序算法</h3><p>计数排序是通过基于哈希的算法，将在队列中出现过的数字进行计数，组成一个由（数字：计数）作为键值对的新数组，之后对新组成的数组从零一直遍历到队列中数字的最大值，将存在的数字按照计数的个数依次放入另外一个数组中，遍历完成以后，新的数组就是最终的排序结果。伪代码流程图如下：<br><img src="/2018/05/15/idx13/coutflow.png" alt=""></p>
<h3 id="7-堆排序算法"><a href="#7-堆排序算法" class="headerlink" title="7. 堆排序算法"></a>7. 堆排序算法</h3><p>每一个数组都可以写成完全二叉树的格式，而当二叉树中每一个父节点都比其子节点大时，就形成了最大堆，最大堆中的根节点是数组中的最大值。将根节点与叶子节点最右边的节点替换，并将替换后的最右叶子结点从堆中剔除，而后对堆进行重排重新形成最大堆，重复这一过程，每次都能选出剩余数组中的最大值，当剩余堆中元素只剩下一个时，排序也就自然完成了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="Qian YJ" />
            
              <p class="site-author-name" itemprop="name">Qian YJ</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qian YJ</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
